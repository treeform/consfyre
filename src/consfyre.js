// Generated by CoffeeScript 1.4.0
(function() {
  var $doc, $fg, $win, Cargo, E, Engine, Gun, Hull, Module, N, Projectile, Rock, S, Thing, W, box, createBall, createGrid, createWorld, ctx, dir, draw, draw_thing, fire1, height, intro, keys, r, requestFrame, resize, shift_keys, ships, thruster1, width, world, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  $win = $(window);

  $doc = $(document);

  width = 1000;

  height = 600;

  $fg = void 0;

  world = void 0;

  ctx = void 0;

  keys = {};

  shift_keys = {};

  $doc.keydown(function(e) {
    keys[e.which] = true;
    return shift_keys[e.which] = e.shiftKey;
  });

  $doc.keyup(function(e) {
    if (!shift_keys[e.which]) {
      return keys[e.which] = false;
    }
  });

  ships = new Image();

  ships.src = "./data/ships2.png";

  fire1 = new Audio();

  fire1.src = './data/fire1.wav';

  thruster1 = new Audio();

  thruster1.src = './data/thruster1.wav';

  intro = new Audio();

  intro.src = './data/hallow-drone-by-dj-chronos.ogg';

  r = function(a, b) {
    return Math.random() * (b - a) + a;
  };

  requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(cb) {
    return window.setTimeout(cb, 1000 / 60);
  };

  resize = function() {
    width = $win.width();
    height = $win.height();
    $fg.attr("width", width);
    return $fg.attr("height", height);
  };

  createWorld = function() {
    var doSleep, gravity, s, worldAABB;
    worldAABB = new b2AABB();
    s = 2000;
    worldAABB.minVertex.Set(-s, -s);
    worldAABB.maxVertex.Set(s, s);
    gravity = new b2Vec2(0, 0);
    doSleep = true;
    world = new b2World(worldAABB, gravity, doSleep);
    return world;
  };

  createBall = function(world, x, y, s, d) {
    var ballBd, ballSd;
    ballSd = new b2CircleDef();
    ballSd.density = d;
    ballSd.radius = s;
    ballSd.restitution = 0.6;
    ballSd.friction = 0.4;
    ballBd = new b2BodyDef();
    ballBd.AddShape(ballSd);
    ballBd.position.Set(x, y);
    return world.CreateBody(ballBd);
  };

  createGrid = function(world, ship) {
    var body, cube, e, make, polyBd, px, py, start_px, xrow, _i, _j, _len, _len1, _ref;
    cube = [[0, 0], [1, 0], [1, 1], [0, 1]];
    polyBd = new b2BodyDef();
    polyBd.userData = ship;
    _ref = ship.grid;
    for (py = _i = 0, _len = _ref.length; _i < _len; py = ++_i) {
      xrow = _ref[py];
      start_px = null;
      for (px = _j = 0, _len1 = xrow.length; _j < _len1; px = ++_j) {
        e = xrow[px];
        make = function(end_px) {
          var polySd1;
          polySd1 = new b2PolyDef();
          polySd1.vertexCount = 4;
          polySd1.userData = [start_px, py, end_px];
          polySd1.vertices[0].Set(start_px * 16, py * 16);
          polySd1.vertices[1].Set(end_px * 16, py * 16);
          polySd1.vertices[2].Set(end_px * 16, (py + 1) * 16);
          polySd1.vertices[3].Set(start_px * 16, (py + 1) * 16);
          polySd1.density = 1.0;
          polyBd.AddShape(polySd1);
          return start_px = null;
        };
        if (e && start_px === null) {
          start_px = px;
        }
        if (!e && start_px !== null) {
          make(px);
        }
      }
      if (start_px !== null) {
        make(px);
      }
    }
    polyBd.position.Set(ship.x, ship.y);
    body = world.CreateBody(polyBd);
    body.m_linearDamping = 0.99;
    body.m_angularDamping = 0.99;
    ship.body = body;
    return body;
  };

  box = void 0;

  draw_thing = function(body, thing) {
    var at_x, at_y, end_x, m_x, module, sh, start_x, tx, ty, _i, _ref;
    ctx.save();
    ctx.translate(body.m_position0.x, body.m_position0.y);
    ctx.rotate(body.m_rotation);
    sh = body.m_shapeList;
    if (sh && sh.m_radius) {
      ctx.beginPath();
      ctx.arc(0, 0, sh.m_radius, 0, Math.PI * 2, true);
      ctx.lineTo(0, 0);
      ctx.closePath();
      ctx.lineWidth = 1;
      ctx.fillStyle = "#777777";
      ctx.fill();
      ctx.strokeStyle = "#BBBBBB";
      ctx.stroke();
    } else {
      while (sh) {
        _ref = sh.m_userData, start_x = _ref[0], at_y = _ref[1], end_x = _ref[2];
        for (at_x = _i = start_x; start_x <= end_x ? _i < end_x : _i > end_x; at_x = start_x <= end_x ? ++_i : --_i) {
          module = thing.grid[at_y][at_x];
          tx = module.tile[0] * 16;
          ty = module.tile[1] * 16;
          m_x = (at_x - (start_x + end_x - 1) / 2) * 16;
          module.x = m_x + sh.m_localCentroid.x;
          module.y = +sh.m_localCentroid.y;
          ctx.save();
          ctx.translate(module.x, module.y);
          if (module.direction === S) {

          } else if (module.direction === N) {
            ctx.rotate(180 / 180 * Math.PI);
          } else if (module.direction === E) {
            ctx.rotate(-90 / 180 * Math.PI);
          } else if (module.direction === W) {
            ctx.rotate(90 / 180 * Math.PI);
          }
          ctx.drawImage(ships, tx, ty, 16, 16, -8, -8, 16, 16);
          ctx.restore();
        }
        /*
                ctx.save()
                ctx.translate(sh.m_localCentroid.x, sh.m_localCentroid.y)
                ctx.beginPath()
                verts = sh.m_coreVertices
                ctx.moveTo(verts[0].x, verts[0].y)
                for v in verts[1..]
                  if v
                    ctx.lineTo(v.x, v.y)
                ctx.strokeStyle = "#F00"
                ctx.closePath()
                ctx.stroke()
                ctx.restore()
        */

        sh = sh.m_next;
      }
    }
    ctx.restore();
    return thing.sim();
  };

  draw = function() {
    var body, camera_x, camera_y, fg_canvas, thing, x, y, _i, _j;
    fg_canvas = $fg[0];
    resize();
    ctx = fg_canvas.getContext('2d');
    ctx.save();
    camera_x = -box.m_position.x + width / 2;
    camera_y = -box.m_position.y + height / 2;
    ctx.translate(camera_x, camera_y);
    ctx.strokeStyle = "#040";
    for (x = _i = -2; _i < 2; x = ++_i) {
      for (y = _j = -2; _j < 2; y = ++_j) {
        ctx.strokeRect(x * 500, y * 500, 500 - 5, 500 - 5);
      }
    }
    body = world.m_bodyList;
    while (body !== null) {
      thing = body.m_userData;
      if (thing) {
        draw_thing(body, thing);
      }
      body = body.m_next;
    }
    world.Step(1 / 60, 1);
    ctx.restore();
    ctx.font = "16px EarthMomma";
    ctx.fillStyle = "#FFF";
    ctx.fillText("Consfyre .01a", 32, 32);
    ctx.fillStyle = "#AAA";
    ctx.font = "8px EarthMomma";
    ctx.fillText("Construct, Conspire, Crossfire", 32, 32 + 12);
    fire1._played = false;
    return requestFrame(draw);
  };

  _ref = "SNEW", S = _ref[0], N = _ref[1], E = _ref[2], W = _ref[3];

  dir = function(d, mag) {
    if (d === S) {
      return new b2Vec2(0, mag);
    } else if (d === N) {
      return new b2Vec2(0, -mag);
    } else if (d === E) {
      return new b2Vec2(mag, 0);
    } else if (d === W) {
      return new b2Vec2(-mag, 0);
    } else {
      throw "invalid direction " + d;
    }
  };

  Thing = (function() {

    function Thing(x, y, grid) {
      this.x = x;
      this.y = y;
      this.grid = grid;
      console.log("made thing");
    }

    Thing.prototype.sim = function() {
      var module, px, py, row, _i, _len, _ref1, _results;
      _ref1 = this.grid;
      _results = [];
      for (py = _i = 0, _len = _ref1.length; _i < _len; py = ++_i) {
        row = _ref1[py];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (px = _j = 0, _len1 = row.length; _j < _len1; px = ++_j) {
            module = row[px];
            if (module) {
              _results1.push(module.sim(this.body));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return Thing;

  })();

  Projectile = (function() {
    var energy;

    function Projectile() {}

    energy = 10;

    Projectile.prototype.sim = function() {
      return "nothing";
    };

    return Projectile;

  })();

  Module = (function() {

    function Module() {}

    Module.prototype.tile = [0, 0];

    Module.prototype.health = 100;

    Module.prototype.density = 1;

    Module.prototype.direction = S;

    Module.prototype.sim = function() {};

    return Module;

  })();

  Rock = (function(_super) {

    __extends(Rock, _super);

    function Rock() {
      return Rock.__super__.constructor.apply(this, arguments);
    }

    Rock.prototype.tile = [16, 25];

    return Rock;

  })(Module);

  Hull = (function(_super) {

    __extends(Hull, _super);

    function Hull() {
      return Hull.__super__.constructor.apply(this, arguments);
    }

    Hull.prototype.tile = [0, 0];

    return Hull;

  })(Module);

  Cargo = (function(_super) {

    __extends(Cargo, _super);

    function Cargo() {
      return Cargo.__super__.constructor.apply(this, arguments);
    }

    Cargo.prototype.tile = [1, 0];

    return Cargo;

  })(Module);

  Engine = (function(_super) {

    __extends(Engine, _super);

    Engine.prototype.tile = [2, 0];

    Engine.prototype.key = null;

    function Engine(direction, key) {
      this.direction = direction;
      this.key = key;
      this.off = true;
      return;
    }

    Engine.prototype.force = function(body, x, y, fx, fy) {
      var f, fire, v;
      body.WakeUp();
      v = new b2Vec2(x, y);
      v.MulM(box.sMat0);
      v.Add(box.m_position);
      f = new b2Vec2(fx, fy);
      f.MulM(box.sMat0);
      body.ApplyImpulse(f, v);
      fire = new b2Vec2(-fx / 100, -fy / 100);
      fire.MulM(box.sMat0);
      ctx.beginPath();
      ctx.arc(v.x, v.y, 5, 0, Math.PI * 2, true);
      ctx.moveTo(v.x, v.y);
      ctx.lineTo(v.x + fire.x, v.y + fire.y);
      ctx.closePath();
      ctx.strokeStyle = "red";
      return ctx.stroke();
    };

    Engine.prototype.sim = function(body) {
      var t, vec;
      if (keys[this.key]) {
        vec = dir(this.direction, -10000);
        this.force(body, this.x, this.y, vec.x, vec.y);
        if (this.off) {
          t = thruster1.cloneNode(true);
          t.volume = .1;
          t.play();
          return this.off = false;
        }
      } else {
        return this.off = true;
      }
    };

    return Engine;

  })(Module);

  Gun = (function(_super) {

    __extends(Gun, _super);

    Gun.prototype.tile = [3, 0];

    Gun.prototype.key = null;

    function Gun(direction, key) {
      this.direction = direction;
      this.key = key;
      return;
    }

    Gun.prototype.sim = function(body) {
      var bullet, f, p, vec;
      if (keys[this.key]) {
        vec = dir(this.direction, -10000);
        p = new b2Vec2(this.x, this.y);
        p.Add(dir(this.direction, 32));
        p.MulM(box.sMat0);
        p.Add(box.m_position);
        bullet = createBall(world, p.x, p.y, 8, .2);
        bullet.m_userData = new Projectile();
        setTimeout((function() {
          return world.DestroyBody(bullet);
        }), 1000);
        f = dir(this.direction, 60000);
        f.MulM(box.sMat0);
        bullet.ApplyImpulse(f, p);
        if (!fire1._played) {
          f = fire1.cloneNode(true);
          f.volume = .3;
          f.play();
          return fire1._played = true;
        }
      }
    };

    return Gun;

  })(Module);

  $(function() {
    var C, G, H, R, i, rock, ship, x, xs, y, ys, z, _i;
    intro.play();
    $fg = $('#fg');
    world = createWorld();
    R = function() {
      return new Rock();
    };
    H = function() {
      return new Hull();
    };
    C = function() {
      return new Cargo();
    };
    E = function(d, k) {
      return new Engine(d, k);
    };
    G = function(d, k) {
      return new Gun(d, k);
    };
    ship = new Thing(0, 0, [[E(W, 39), 0, E(N, 38), 0, E(E, 37)], [H(), H(), C(), H(), H()], [0, H(), C(), H(), 0], [0, 0, C(), 0, 0], [0, G(S, 32), E(S, 40), G(S, 32), 0]]);
    box = createGrid(world, ship);
    for (i = _i = 0; _i < 100; i = ++_i) {
      z = 1000;
      x = r(-z, z);
      y = r(-z, z);
      xs = r(10, 100);
      ys = r(10, 100);
      rock = new Thing(x, y, [[0, R(), R(), R(), 0], [R(), R(), R(), R(), R()], [R(), R(), R(), R(), R()], [R(), R(), R(), R(), R()], [0, R(), R(), R(), 0]]);
      createGrid(world, rock);
    }
    console.log("world", world, "box", box);
    return draw();
  });

}).call(this);
